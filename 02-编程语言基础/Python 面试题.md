# Python 面试题

tags: python

---



### 1. 垃圾回收机制

**引用计数为主，分代收集为辅。**在 python 中，如果一个对象的引用数为 0， python 虚拟机就会回收这个对象的内存。

- 导致引用计数 +1 的情况：

  > - 对象被创建： a = classname()
  > - 对象被引用： b = a
  > - 对象被作为参数，传入到一个函数中： func(a)
  > - 对象作为一个元素，存储在容器内： list_name = [a, a]

- 导致引用计数 -1 的情况：

  > - 对象的别名被显式销毁， 如： del a 
  > - 对象的别名被赋予新的对象，如：a = other_class()
  > - 一个对象离开它的作用域，如函数执行完毕时，func 函数中的局部变量
  > - 对象所在的容器被销毁，或从容器中删除对象

## 循环引用导致内存泄漏

```
c1=ClassA() # 内存 1 引用计数 +1 = 1
c2=ClassA() # 内存 2 引用计数 +1 = 1
c1.t=c2  #  内存 2 引用计数 +1 = 2
c2.t=c1  #  内存 1 引用计数 +1 = 2
del c1  # 内存 1 引用计数 -1 = 1
del c2  # 内存 2 引用计数 -1 = 1
```

如上文描述，由于**循环引用**，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。

**垃圾回收机制模块： gc**

## 迭代器，可迭代对象，生成器

- **可迭代对象：**可以迭代的对下，是一个容器，可以使用for循环来遍历该元容器的所有元素
- **迭代器：** 满足迭代器协议的都叫做迭代器
  - 迭代器中必须具有 `__iter__`方法 ，该方法返回一个迭代器对象。
  - 迭代器中必须有一个`_next_`方法，当该方法被调用时，会给出可迭代对象的下一个元素，如果到达对象末尾，则触发`StopIteration`异常。
- **生成器：**python使用生成器对延迟操作提供支持。即在需要的时候才进行计算产生结果。

可迭代对下内部只实现了 `__iter__` 或 `__getitem__` 方法；而迭代器实现了迭代器协议，也就是内部实现了 `__next__` 与 `__iter__` 方法。

迭代器一定是可迭代对象，但可迭代对象不一定是迭代器。

python 两种方法提供生成器：

- 生成器函数：使用 yield 语句而不是 return 语句返回结果
- 生成器表达式：生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表

生成器的特性：

- 语法上和函数类似：生成器使用yield语句返回一个值，而常规函数使用return语句返回一个值
- 自动实现迭代器协议：
- 状态挂起：生成器使用yield语句返回一个值，而常规函数使用return语句返回一个值